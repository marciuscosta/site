<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Marcius Costa</title>
	<atom:link href="/index.php/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Profissional em redes de computadores e segurança cibernética</description>
	<lastBuildDate>Mon, 14 Mar 2022 21:34:24 +0000</lastBuildDate>
	<language>pt-BR</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.9.1</generator>
	<item>
		<title>Wazuh criando regra no pfSense para bloquear IP de atacante</title>
		<link>/index.php/2022/03/11/wazuh-criando-regra-no-pfsense-para-bloquear-ip-de-atacante/</link>
		
		<dc:creator><![CDATA[marcius]]></dc:creator>
		<pubDate>Fri, 11 Mar 2022 01:52:43 +0000</pubDate>
				<category><![CDATA[Segurança]]></category>
		<guid isPermaLink="false">http://localhost/?p=32</guid>

					<description><![CDATA[Quando o Wazuh identificar um ataque, ele pode criar uma regra em um ou mais pfSense para bloquear o IP desse atacante.]]></description>
										<content:encoded><![CDATA[
<p>O cenário é o seguinte:</p>



<ul><li>Debian Bullseye versão 5.10.92-1 com wazuh-manager 4.2.5-1 e elasticsearch, kibana e filebeat nas versões 7.14.2</li><li>pfSense CE 2.6.0-RELEASE</li><li>Ambos os servidores acima foram virtualizados em VirtualBox 6.1.32-2 em Arch Linux 5.16.13-arch1-1</li><li>O artigo parte do princípio que o wazuh-manager e o pfSense já estejam instalados, configurados e funcionais, como descrito acima</li><li>IP do servidor com wazuh-manager: 10.0.2.201/24</li><li>IP do servidor com pfSense: 10.0.2.200/24</li></ul>



<h2>..::| Instalando o agente no pfSense</h2>



<p>Pra facilitar o trabalho de fazer as configurações no pfSense, habilite o acesso via SSH nesse servidor, indo em <em>System -> Advanced -> </em>marque a opção<em> &#8220;Enable Secure Shell&#8221;</em>:</p>



<figure class="wp-block-image size-full"><img width="1162" height="314" src="/wp-content/uploads/2022/03/2-ssh-pfsense.png" alt="" class="wp-image-56"/></figure>



<p>Acesse o pfSense via SSH com o usuário root e instale o agente do Wazuh para FreeBSD 12 (base do pfSense):</p>



<pre class="wp-block-code"><code>pkg add https://pkg.freebsd.org/FreeBSD:12:amd64/quarterly/All/wazuh-agent-4.1.5.pkg</code></pre>



<figure class="wp-block-image size-full"><img loading="lazy" width="1121" height="737" src="/wp-content/uploads/2022/03/2-install-wazuh-agent.png" alt="" class="wp-image-58"/></figure>



<p>Configure o agente do Wazuh, editando o arquivo<em> /var/ossec/etc/ossec.conf </em>e alterando a palavra &#8220;<em>IP</em>&#8221; dentro da tag &#8220;<em>&lt;address>IP&lt;/address></em>&#8221; para o IP do servidor do Wazuh (debian), que nesse artigo é o 10.0.2.201, ficando assim:</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="545" height="244" src="/wp-content/uploads/2022/03/2-wazuh-agent-config.png" alt="" class="wp-image-59"/></figure>



<p>Salve e saia do arquivo.</p>



<p>Agora vá na interface web do pfSense e instale a package &#8220;<em>Shellcmd</em>&#8221; para fazer com que o wazuh-agent inicie no boot desse servidor. Vá em <em>System -> Package Manager -> Available Packages</em>, procure por &#8220;<em>Shellcmd</em>&#8221; e o instale.</p>



<p>Depois de instalado, acesse-o em <em>Services -> Shellcmd</em>.</p>



<p>Clique no botão &#8220;<em>+ Add</em>&#8221; e preencha o campo &#8220;<em>Command</em>&#8221; com &#8220;<em>/usr/local/etc/rc.d/wazuh-agent start</em>&#8221; e depois clique me &#8220;Save&#8221;.</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="1145" height="305" src="/wp-content/uploads/2022/03/2-shellcmd.png" alt="" class="wp-image-60"/></figure>



<p>Agora crie uma regra para o agente se conectar com o wazuh-manager, indo em <em>Firewall -> Rules -> LAN -> ADD</em> e preencha da seguinte forma:</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="1155" height="855" src="/wp-content/uploads/2022/03/2-regra-wazuh-agent.png" alt="" class="wp-image-61"/><figcaption>Lembre-se de substituir o IP 10.0.2.201 pelo do servidor onde está o wazuh-manager na sua arquitetura</figcaption></figure>



<p>Salve e aplique a regra. Tome cuidado para que ela não seja bloqueada por uma possível outra regra de bloqueio antes dessa.</p>



<p>Agora volte ao terminal conectado via SSH e habilite o agente:</p>



<pre class="wp-block-code"><code>/usr/local/etc/rc.d/wazuh-agent enable</code></pre>



<p>Inicie o agente:</p>



<pre class="wp-block-code"><code>/usr/local/etc/rc.d/wazuh-agent start</code></pre>



<p>Verifique se o agente iniciou normalmente:</p>



<pre class="wp-block-code"><code>/usr/local/etc/rc.d/wazuh-agent onestatus</code></pre>



<figure class="wp-block-image size-full"><img loading="lazy" width="708" height="150" src="/wp-content/uploads/2022/03/2-wazuh-agent-status.png" alt="" class="wp-image-62"/></figure>



<p>Agora no painel do Wazuh, verifique se o novo agente se conectou ao servidor, indo no menu do <em>Wazuh -> Management -> Status</em>:</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="897" height="840" src="/wp-content/uploads/2022/03/2-wazuh-agent-conectado.png" alt="" class="wp-image-63"/></figure>



<h2>..::| Script de bloqueio</h2>



<p>Agora volte para a conexão SSH com o servidor do pfSense para criarmos um script que será responsável pela criação de regras de bloqueio com base em regras acionadas no wazuh-manager.</p>



<p>Crie o arquivo <em>/var/ossec/active-response/bin/easyrule-pf.sh</em> com o seguinte conteúdo:</p>



<pre class="wp-block-code"><code>#!/bin/sh
# Script para adicionar IPs bloqueados pelo Wazuh no pfSense dentro do aliase "EasyRuleBlockHosts"
# Expect: srcip
# Author: Marcius da C. Silveira
# Last modified: Mar 3, 2022

ACAO=$1
USUARIO=$2
IP=$3


# logando as atividades desse script
echo "`date` $0 $1 $2 $3 $4 $5" >> /var/ossec/logs/active-responses.log


# Erro se o IP nao for mencionado nos argumentos
if &#91; "x${IP}" = "x" ]; then
   echo "$0: Falta o IP no terceiro argumento &lt;acao> &lt;usuario> (IP)"
   exit 1;
fi


# Coletando os nomes das interfaces do pfSense
INTF=`/usr/local/bin/xmllint --xpath 'pfsense/interfaces/child::*' /conf/config.xml | grep '^&lt;' | tr -d '&lt;' | tr -d '>'`
QTDINTF=`echo ${INTF} | wc -w`
# a ACAO sera feita para cada interface coletada acima
# caso deseje executar a ACAO para interfaces especificas, especifique elas na varialvel INTF colocando espacos entre cada uma, por exemplo:
# INTF="wan lan"
while &#91; ${QTDINTF} != 0 ]; do
	IF=`echo ${INTF} | cut -d ' ' -f ${QTDINTF}`
	# Se o argumento ACAO for "add"
	if &#91; "x${ACAO}" = "xadd" ]; then
		/usr/local/bin/easyrule	block $IF "${IP}"
	# Se o argumento ACAO for "delete"
	elif &#91; "x${ACAO}" = "xdelete" ]; then
		/usr/local/bin/easyrule unblock $IF "${IP}"

	# Se o argumento ACAO for invalido
	else
	   echo "$0: acao invalida: ${ACAO}"
	fi
 	QTDINTF=$((QTDINTF-1))
done

exit 1;</code></pre>



<p>Dê as permissões 750 para esse arquivo:</p>



<pre class="wp-block-code"><code>chmod 750 /var/ossec/active-response/bin/easyrule-pf.sh</code></pre>



<p>Reinicie o agente:</p>



<pre class="wp-block-code"><code>/usr/local/etc/rc.d/wazuh-agent restart</code></pre>



<p>Agora vá até o servidor Debian onde está o wazuh-manager, e edite o arquivo <em>/var/ossec/etc/ossec.conf</em> acrescentando, depois do último &#8220;<em>&lt;/command></em>&#8220;, o seguinte conteúdo:</p>



<pre class="wp-block-code"><code>  &lt;command>
    &lt;name>easyrule-pfsense&lt;/name>
    &lt;executable>easyrule-pf.sh&lt;/executable>
    &lt;timeout_allowed>yes&lt;/timeout_allowed>
  &lt;/command>

  &lt;active-response>
    &lt;command>easyrule-pfsense&lt;/command>
    &lt;location>defined-agent&lt;/location>
    &lt;agent_id>001&lt;/agent_id>
    &lt;rules_id>5758&lt;/rules_id>
    &lt;disabled>no&lt;/disabled>
  &lt;/active-response></code></pre>



<figure class="wp-block-image size-full"><img loading="lazy" width="671" height="440" src="/wp-content/uploads/2022/03/2-wazuh-manager-active-response.png" alt="" class="wp-image-64"/></figure>



<p>Nesse exemplo acima eu especifiquei o agente recém instalado no pfSense, cujo o código é 001. Caso queira que mais de um agente execute a ação de criar regras de bloqueio, adicione os códigos desses agentes os separando por uma vírgula (por exemplo: <code>&lt;agent_id>001,009,021&lt;/agent_id></code>). Nesse caso, lembre-se de colocar o script &#8220;<em>easyrule-pf.sh</em>&#8221; nesses outros servidores também, como descrito acima, assim como configurar suas permissões.</p>



<p>Aqui nesse exemplo eu também especifiquei uma regra que, quando acionada em algum ataque, irá executar o script &#8220;<em>easyrule-pf.sh</em>&#8221; no(s) agente(s) configurado(s) em &#8220;<em>&lt;agent_id></em>&#8220;. É possível colocar, ao invés de apenas uma regra, várias delas também as separando por vírgula, ou também um grupo de regras, mas nesse caso não se usa as tags &#8220;<em>&lt;rules_id>&lt;/rules_id></em>&#8220;, e sim &#8220;<em>&lt;rules_group>&lt;/rules_group></em>&#8220;, inserindo os nomes dos grupos que pretende usar (por exemplo: <code>&lt;rules_group>authentication_failed|authentication_failures&lt;/rules_group></code>). Mais informações sobre as possibilidades de configuração dos tipos de gatilhos você encontra <a href="https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/active-response.html" target="_blank" rel="noreferrer noopener">aqui</a>.</p>



<p>Reinicie o wazuh-manager:</p>



<pre class="wp-block-code"><code>systemctl restart wazuh-manager</code></pre>



<h2>..::| Testando</h2>



<p>No exemplo acima, especifiquei uma regra cuja sua configuração detecta várias tentativas de login via SSH em um servidor. Para testar se o script que adiciona IP à regras de bloqueio no pfSense está funcionando, desabilitei a proteção SSH do pfSense indo em <em>System -> Advanced</em>, na primeira aba chamada &#8220;<em>Admin Access</em>&#8220;, e logo abaixo em &#8220;<em>Login Protection</em>&#8221; adicionei o IP da minha máquina no campo &#8220;<em>Pass list</em>&#8220;, para que o pfSense permita que eu faça várias tentativas de login pelo SSH ao invés de me bloquear automaticamente por ele mesmo.</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="1150" height="391" src="/wp-content/uploads/2022/03/2-pass-list-ip.png" alt="" class="wp-image-69"/></figure>



<p>Agora tente se conectar várias vezes seguidas via SSH com uma senha errada, para testar se a regra 5758 será acionada fazendo com que o active-response configurado acima crie uma regra de bloqueio nas abas de cada interface de rede do pfSense.</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="1171" height="302" src="/wp-content/uploads/2022/03/2-easyrule-1.png" alt="" class="wp-image-70"/></figure>



<figure class="wp-block-image size-full"><img loading="lazy" width="1163" height="301" src="/wp-content/uploads/2022/03/2-easyrule-2.png" alt="" class="wp-image-71"/></figure>



<p>Veja que o script <em>easyrule-pf.sh</em>, usado no active-response, funcionou perfeitamente. Foi criada uma regra de bloqueio e um aliase chamado &#8220;<em>EasyRuleBlockHosts</em>&#8221; seguido do nome da interface, onde nele irá constar os IPs passados pelo wazuh-manager quando acionada a regra especificada nas configurações do active-response.</p>



<h2>..::| Anti-lockout</h2>



<p>Um detalhe importante, que deve ser observado, é quanto a regra criada na aba LAN:</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="1160" height="534" src="/wp-content/uploads/2022/03/2-easyrule-lan.png" alt="" class="wp-image-73"/></figure>



<p>Veja que o sistema &#8220;<em>Anti-Lockout</em>&#8220;, que por padrão vem ativado no pfSense para evitar que o administrador desse sistema não seja impedido de acessá-lo, ficará sempre em primeiro na lista de regras dessa aba. Como o teste que fiz acima era justamente para bloquear um acesso via SSH partindo de um IP na rede LAN do pfSense, a máquina usada no ataque não ficará bloqueada de fato, por conta desse &#8220;<em>Anti-Lockout</em>&#8220;.</p>



<p>Uma solução nesse caso é criar uma regra de liberação da porta 80 ao pfSense, colocando em primeiro na lista da aba LAN, acima da regra de bloqueio que usa o aliase &#8220;<em>EasyRuleBlockHostsLAN</em>&#8220;, assim:</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="1156" height="534" src="/wp-content/uploads/2022/03/2-anti-lockout-manual.png" alt="" class="wp-image-74"/><figcaption>Observe que a regra deve ficar sempre na primeira posição, e em segundo a regra criada pelo &#8220;<em>easyrule-pf.sh</em>&#8220;</figcaption></figure>



<p>Depois desative o sistema &#8220;<em>Anti-Lockout</em>&#8221; (em <em>System -> Advanced -></em> marcar a opção &#8220;<em>Disable webConfigurator anti-lockout rule</em>&#8220;). Nesse momento você notará que não haverá mais aquela regra padrão no topo da aba LAN, ficando parecida com a imagem acima.</p>



<h2>..::| Conclusão e considerações finais</h2>



<p>Com essa técnica será possível ter uma blacklist própria com base em ataques direcionados a sua rede, e replicar para todos os seus gateways o IP do atacante, bloqueando-o antes que o mesmo tente um novo ataque por outros caminhos.</p>



<p>É importante lembrar também que os IPs de atacantes, na maioria das vezes, não são sempre os mesmos. Ou seja, depois de alguns dias as operadoras fornecem um novo IP para seus usuários, e isso pode implicar em bloqueios errados, pois um cliente da sua empresa pode acabar recebendo um IP que foi usado recentemente em um ataque, impossibilitando-o de acessar um servidor da sua rede, por exemplo. </p>



<p>Por isso, é importante colocar um tempo de bloqueio para cada IP, e após esses dias tirá-lo dos aliases das regras criadas pelo &#8220;<em>easyrule-pf.sh</em>&#8220;. Isso é configurável através da opção &#8220;<em>&lt;timeout></em>&#8221; dentro do &#8220;<em>&lt;active-response>&lt;/active-response></em>&#8221; no &#8220;<em>/var/ossec/etc/ossec.conf</em>&#8221; dentro do servidor do wazuh-manager, e colocar um valor em segundos (por exemplo, para 8 dias de bloqueio: <code>&lt;timeout>691200&lt;/timeout></code>).</p>



<p></p>



<blockquote class="wp-block-quote is-style-default"><p>Fontes:<br><a href="https://techviewleo.com/how-to-install-wazuh-server-on-debian/" target="_blank" rel="noreferrer noopener">https://techviewleo.com/how-to-install-wazuh-server-on-debian/</a><br><a href="https://documentation.wazuh.com/" target="_blank" rel="noreferrer noopener">https://documentation.wazuh.com/</a><br><a href="https://groups.google.com/g/wazuh/c/pc4IAOIjW-E?pli=1" target="_blank" rel="noreferrer noopener">https://groups.google.com/g/wazuh/c/pc4IAOIjW-E?pli=1</a><br><a href="https://freebsd.pkgs.org/12/freebsd-amd64/wazuh-agent-4.1.5.pkg.html" target="_blank" rel="noreferrer noopener">https://freebsd.pkgs.org/12/freebsd-amd64/wazuh-agent-4.1.5.pkg.html</a><br><a href="https://docs.netgate.com/pfsense/en/latest/development/boot-commands.html" target="_blank" rel="noreferrer noopener">https://docs.netgate.com/pfsense/en/latest/development/boot-commands.html</a><br><a href="https://documentation.wazuh.com/current/user-manual/capabilities/active-response/how-it-works.html#active-response-configuration" target="_blank" rel="noreferrer noopener">https://documentation.wazuh.com/current/user-manual/capabilities/active-response/how-it-works.html#active-response-configuration</a><br><a href="https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/active-response.html#reference-ossec-active-response" target="_blank" rel="noreferrer noopener">https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/active-response.html#reference-ossec-active-response</a></p></blockquote>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Redimensionando disco virtual no Debian com partição LVM sem perda de dados</title>
		<link>/index.php/2022/03/11/redimensionando-disco-virtual-no-debian-com-particao-lvm-sem-perda-de-dados/</link>
		
		<dc:creator><![CDATA[marcius]]></dc:creator>
		<pubDate>Fri, 11 Mar 2022 01:21:16 +0000</pubDate>
				<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">http://localhost/?p=12</guid>

					<description><![CDATA[Nesse artigo, explico como aumentar uma partição LVM de um disco virtual redimensionado sem ter que refazer a partição, ou seja, sem perda de dados.]]></description>
										<content:encoded><![CDATA[
<p></p>



<p>O cenário é o seguinte:</p>



<ul><li>Servidor Debian Buster com Kernel 4.19.194-2 virtualizado em VirtualBox</li><li>Disco virtual de 50GB precisa ser aumentado para 100GB</li><li>Partição única em LVM no segundo disco (/dev/sdb)</li></ul>



<p></p>



<h1>..::|&nbsp;<strong>Redimensionando</strong></h1>



<p>Após aumentar o disco virtual no VirtualBox com o servidor Debian desligado, inicie-o e verifique se o novo tamanho foi reconhecido:</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="502" height="179" src="http://localhost/wp-content/uploads/2022/03/1-fdisk-sdb.png" alt="" class="wp-image-16"/></figure>



<p>Caso o disco esteja montado, lembre-se de desmonta-lo:</p>



<pre class="wp-block-code"><code>test@debian:~$ sudo umount /dev/sdb1</code></pre>



<p>Verifique as informações do volume lógico para pegar o nome dele. Execute “<em>sudo lvscan</em>“:</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="470" height="35" src="http://localhost/wp-content/uploads/2022/03/1-lvscan-edit-1.png" alt="" class="wp-image-17"/></figure>



<p>Desative o volume lógico:</p>



<pre class="wp-block-code"><code>test@debian:~$ sudo lvchange -a n /dev/test/lvol0</code></pre>



<p>Caso já não o tenha, instale o “<em>parted</em>” para redimensionar a partição LVM:</p>



<pre class="wp-block-code"><code>test@debian:~$ sudo apt-get install parted</code></pre>



<p>Inicialize o&nbsp;<em>parted</em>&nbsp;no disco a ser redimensionado:</p>



<pre class="wp-block-code"><code>test@debian:~$ sudo parted /dev/sdb</code></pre>



<p>No ambiente do <em>parted</em>, verifique a capacidade total do disco com o comando “<em>print</em>” afim de saber para qual tamanho pode-se aumentar a partição /dev/sdb1 com o comando “<em>resizepart</em>“:</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="543" height="497" src="http://localhost/wp-content/uploads/2022/03/1-parted-edit-1.png" alt="" class="wp-image-18"/></figure>



<p>Insira as informações mostradas pelo comando “<em>print</em>” nas duas perguntas que o comando “<em>resizepart</em>” faz, conforme os destaques em vermelho na imagem acima.</p>



<p>Agora aumente o physical volume dessa partição com o comando “<em>sudo pvresize /dev/sdb1</em>“.</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="612" height="50" src="http://localhost/wp-content/uploads/2022/03/1-pvresize-sdb1png.png" alt="" class="wp-image-20"/><figcaption><em>Com o comando “sudo pvs” você pode confirmar se o tamanho do physical volume foi aumentado com sucesso.</em></figcaption></figure>



<p>Redimensione o volume lógico para o máximo disponível:</p>



<pre class="wp-block-code"><code>test@debian:~$ sudo lvextend -l +100%FREE /dev/test/lvol0</code></pre>



<figure class="wp-block-image size-full"><img loading="lazy" width="801" height="65" src="http://localhost/wp-content/uploads/2022/03/1-lvextend-edit.png" alt="" class="wp-image-21"/></figure>



<p>Ative novamente o volume lógico com o comando:</p>



<pre class="wp-block-code"><code>test@debian:~$ sudo lvchange -a y /dev/test/lvol0</code></pre>



<p>Faça uma checagem da partição antes de redimensioná-la (é necessário):</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="637" height="130" src="http://localhost/wp-content/uploads/2022/03/1-e2fsck.png" alt="" class="wp-image-22"/></figure>



<p>Execute o <em>resize2fs</em> nessa partição para que o novo tamanho seja reconhecido:</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="549" height="72" src="http://localhost/wp-content/uploads/2022/03/1-resize2fs.png" alt="" class="wp-image-23"/></figure>



<p>Pronto!</p>



<p>Agora basta montar a partição com o comando&nbsp;<em>mount</em>.</p>



<pre class="wp-block-code"><code>test@debian:~$ sudo mount /dev/test/lvol0 /destino_da_montagem</code></pre>



<figure class="wp-block-image size-full"><img loading="lazy" width="496" height="177" src="http://localhost/wp-content/uploads/2022/03/1-mount.png" alt="" class="wp-image-24"/></figure>



<p>Caso o redimensionamento seja em um disco onde esteja rodando a raiz do sistema, basta usar um live-cd e seguir esses mesmos passos.</p>



<blockquote class="wp-block-quote"><p><strong>Fontes:</strong><br><a href="https://www.tecmint.com/parted-command-to-create-resize-rescue-linux-disk-partitions/">https://www.tecmint.com/parted-command-to-create-resize-rescue-linux-disk-partitions/</a><br><a href="https://wiki.debian.org/LVM" target="_blank" rel="noreferrer noopener">https://wiki.debian.org/LVM</a></p></blockquote>



<p></p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
